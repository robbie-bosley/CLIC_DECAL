#include "MyHitPositions.h"

#include <iostream>
#include <math.h>
#include <sstream>
#include <fstream>
#include <utility>
#include <cmath>
#include <string>

#include "TFile.h"
//#include "/cvmfs/clicdp.cern.ch/software/ROOT/6.12.06/x86_64-slc6-gcc7-opt/include/TFile.h"
#include "TH1.h"
#include "TH2.h"
#include "TH3.h"
#include "TTree.h"
#include "TBranch.h"

#include <EVENT/LCCollection.h>
#include <EVENT/MCParticle.h>
#include <EVENT/SimCalorimeterHit.h>
#include <UTIL/CellIDDecoder.h>

// ----- include for verbosity dependend logging ---------
#include "marlin/VerbosityLevels.h"

#ifdef MARLIN_USE_AIDA
#include <marlin/AIDAProcessor.h>
#include <AIDA/IHistogramFactory.h>
#include <AIDA/ICloud1D.h>
#include <AIDA/ITree.h>
//#include <AIDA/IHistogram1D.h>
#endif // MARLIN_USE_AIDA

using namespace std ;
using namespace lcio ;
using namespace marlin ;


MyHitPositions aMyHitPositions ;


MyHitPositions::MyHitPositions() : Processor("MyHitPositions") {

    // modify processor description
    _description = "MyHitPositions attempts to extract the ECAL hit positions, as well as the layer, stave and module information." ;


    // register steering parameters: name, description, class-variable, default value
    registerInputCollection( LCIO::MCPARTICLE,
            "CollectionName" , 
            "Name of the MCParticle collection"  ,
            _colName ,
            std::string("MCParticle")
    );

    registerInputCollection( LCIO::SIMCALORIMETERHIT,
			     "ECalBarrelCollection" ,
			     "Ecal Barrel Hits",
			     CalHits,
			     std::string("ECalBarrelCollection"));

    registerProcessorParameter("HistogramDump" ,
			       "Name of root file to dump histograms to" ,
			       rootfile,
			       std::string("HitPositions.root"));
    
    registerProcessorParameter("MCEnergy" ,
			       "MC particle energy" ,
			       mcenergy,
			       int(0));

    
}



void MyHitPositions::init() { 

    streamlog_out(DEBUG) << "   init called  " << std::endl ;

    // usually a good idea to
    printParameters() ;

    _nRun = 0 ;
    _nEvt = 0 ;

    ClearVector( vX, vY, vZ, vLayer, vStave, vModule, vEnergy, vCellID0, vCellID1 );

    /*    AIDA::IHistogramFactory* pHistogramFactory=marlin::AIDAProcessor::histogramFactory( this );
    AIDA::ITree* pTree=marlin::AIDAProcessor::tree( this );
    
    if(  pHistogramFactory!=0 )
      {
        if (!(pTree->cd( "/" + name() + "/")))
          {
            pTree->mkdir( "/" + name() + "/" );
            pTree->cd( "/" + name() + "/");
          }
        tHits = new TTree("ScEven", "Tree containing Even Scintillator Calorimeter Hit information");
      }
    */


    // TH1F* hX = new TH1F("hX", "X position", 6000, -3000.0, 3000.0);
    // TH1F* hY = new TH1F("hY", "Y position", 6000, -3000.0, 3000.0);
    // TH1F* hZ = new TH1F("hZ", "Z position", 6000, -3000.0, 3000.0);
    // TH1F* hLayer = new TH1F("hLayer", "Layer", 50, 0.0, 50.0);
    // TH1F* hStave = new TH1F("hStave", "Stave", 15, 0.0, 15.0);
    // TH1F* hModule = new TH1F("hModule", "Module", 10, 0.0, 10.0);
    // TH1F* hEnergy = new TH1F("hEnergy", "Energy", 5000, 0.0, 5000.0);
}


void MyHitPositions::processRunHeader( LCRunHeader* run) { 

    _nRun++ ;
} 



void MyHitPositions::processEvent( LCEvent * evt ) { 


    // this gets called for every event 
    // usually the working horse ...


#ifdef MARLIN_USE_AIDA

    // define a histogram pointer
    //static AIDA::ICloud1D* hMCPEnergy ;    

    //if( isFirstEvent() ) { 

    //    hMCPEnergy = AIDAProcessor::histogramFactory(this)->
    //        createCloud1D( "hMCPEnergy", "energy of the MCParticles", 100 ) ; 

    //}
#endif // MARLIN_USE_AIDA

    // try to get lcio collection (exits if collection is not available)
    // NOTE: if the AIDAProcessor is activated in your steering file and Marlin is linked with
    //      RAIDA you may get the message: "*** Break *** segmentation violation" followed by a
    //      stack-trace (generated by ROOT) in case the collection is unavailable. This happens
    //      because ROOT is somehow catching the exit signal commonly used to exit a program
    //      intentionally. Sorry if this messsage may confuse you. Please ignore it!
    LCCollection* mccol = NULL ;
    try
      {
	mccol = evt->getCollection( _colName );
      }
    catch( lcio::DataNotAvailableException e )
      {
	streamlog_out(WARNING) << _colName << " collection not available" << std::endl;
	mccol = NULL;
	return;
      }


    LCCollection* calhit_collection = NULL;
    try
      {
	calhit_collection = evt->getCollection( CalHits );
      }
    catch( lcio::DataNotAvailableException e )
      {
	streamlog_out(WARNING) << CalHits << " collection not available" << std::endl;
	calhit_collection = NULL;
	return;
      }

    ClearVector( vX, vY, vZ, vLayer, vStave, vModule, vEnergy, vCellID0, vCellID1 ); // Add in Cell IDs
    
    //std::cout << "vX is of size " << vX.size() << std::endl;
    GetStuff (calhit_collection, vX, vY, vZ, vLayer, vStave, vModule, vEnergy, vCellID0, vCellID1);
    int nhits = calhit_collection->getNumberOfElements() ;
    //    int truthE = mccol->getEnergy();
    
    float recoenergy = (-calib_b + pow(pow(calib_b, 2)-(4*calib_a*(calib_c-nhits)), 0.5))/(2*calib_a);
    std::cout << "recoenergy is " << recoenergy << std::endl;

    ///////////////////////////////////////////////////////////////
    for (int i=0; i<vX.size(); i++) {
      if ((vLayer[i]<0) || (vStave[i] < 0) || (vModule[i] < 0)) {
	std::cout << "HELP! i and vLayer[i] = " << i << "/" << vLayer.size() << "   " << vLayer[i] << std::endl;
      }
    }

    float l = 0;
    for (int i=0; i<vEnergy.size(); i++) {
      if (l < vEnergy[i]) {
	l = vEnergy[i];
      } 
    }
    std::cout << l << "\n";

    switch(mcenergy) {
    case 10 : hNHits->SetBins(2001, -0.5, 2000.5);
      hRecoEnergy->SetBins(501, -0.02, 20.02);
      break;
    case 20 : hNHits->SetBins(2001, 999.5, 3000.5);
      hRecoEnergy->SetBins(501, 9.98, 30.02);
      break;
    case 30 : hNHits->SetBins(2001, 1999.5, 4000.5);
      hRecoEnergy->SetBins(501, 19.98, 40.02);
      break;
    case 40 : hNHits->SetBins(2001, 2499.5, 4500.5);
      hRecoEnergy->SetBins(501, 29.98, 50.02);
      break;
    case 50 : hNHits->SetBins(2001, 3499.5, 5500.5);
      hRecoEnergy->SetBins(501, 39.98, 60.02);
      break;
    case 100 : hNHits->SetBins(2001, 2999.5, 11000.5);
      hRecoEnergy->SetBins(501, 79.96, 120.04);
      break;
    case 150 : hNHits->SetBins(2001, 7499.5, 15500.5);
      hRecoEnergy->SetBins(501, 129.96, 170.04);
      break;
    case 200 : hNHits->SetBins(2001, 11999.5, 20000.5);
      hRecoEnergy->SetBins(501, 179.96, 220.04);
      break;
    case 250 : hNHits->SetBins(2001, 16499.5, 24500.5);
      hRecoEnergy->SetBins(501, 229.96, 270.04);
      break;
    case 300 : hNHits->SetBins(2001, 20999.5, 29000.5);
      hRecoEnergy->SetBins(501, 279.96, 320.04);
      break;
    default: std::cout << "HELP! mcenergy isn't what was expected. Currently able to do 10, 20, 30, 40, 50, 100, 150, 200, 250, 300" << std::endl;
      break;
    }


    FillHistogram(vX, hX);
    FillHistogram(vY, hY);
    FillHistogram(vZ, hZ);
    FillHistogramInt(vLayer, hLayer);
    FillHistogramInt(vStave, hStave);
    FillHistogramInt(vModule, hModule);
    FillHistogram(vEnergy, hEnergy);

    hNHits->Fill(nhits);
    hRecoEnergy->Fill(recoenergy);

    Fill2DHistogram(vX, vY, hXY);

    for (int i = 0; i < vX.size(); i++) {
      float r = sqrt((vX[i]*vX[i])+(vY[i]*vY[i]));
      if (r < 15000) {
	hYLayer->Fill(vY[i], vLayer[i]);
	hXLayer->Fill(vX[i], vLayer[i]);
      }
      if ((vX[i] < 1) && (vX[i] > -1) && (vY[i] < 1500) && (vY[i] > -1500)) {
	std::cout << "Cell ID: " << vCellID0[i] << ", " << vCellID1[i] << std::endl; // add calhit collection, and number of hits in collection.
	std::cout << "vX size is " << vX.size() << " and number of hits in collection " <<  CalHits << " is " << calhit_collection->getNumberOfElements() << std::endl;
	std::cout << "R:" << r << "  X:" << vX[i] << "  Y:" << vY[i] << "  Z:" << vZ[i] << "  Layer:" << vLayer[i] << "  Module:" << vModule[i] << "  Stave:" << vStave[i] << std::endl;
      }
      
      if ((vLayer[i] < 0) || (vStave[i] < 0) || (vModule[i] < 0)) {
	std::cout << "EVENT NUMBER IS " << _nEvt << std::endl;
	std::cout << "Layer: " << vLayer[i] << " = " << int(vLayer[i]) << std::endl; 
	std::cout << "Stave: " << vStave[i] << " = " << int(vStave[i]) << std::endl;
	std::cout << "Module: " << vModule[i] << " = " << int(vModule[i]) << std::endl;
      }
    }
    //Something going wrong here. Getting non-integer layers.


    //Fill3DHistogram(vX, vY, vLayer, hXYLayer);

    // Alternativelly if you do not want Marlin to exit in case of a non-existing collection
    // use the following (commented out) code:
    //LCCollection* col = NULL;
    //try{
    //    col = evt->getCollection( _colName );
    //}
    //catch( lcio::DataNotAvailableException e )
    //{
    //    streamlog_out(WARNING) << _colName << " collection not available" << std::endl;
    //    col = NULL;
    //}

    // this will only be entered if the collection is available
    if( mccol != NULL ){

        int nMCP = mccol->getNumberOfElements()  ;
	std::cout << "number of MCP is " << nMCP << std::endl;
        for(int i=0; i< nMCP ; i++){

            MCParticle* p = dynamic_cast<MCParticle*>( mccol->getElementAt( i ) ) ;
	    
	    if (p->isCreatedInSimulation() == false) {
	      hMCEnergy->Fill(p->getEnergy());
	    }
	    
	    //#ifdef MARLIN_USE_AIDA
            // fill histogram from LCIO data :
	    // hMCPEnergy->fill( p->getEnergy() ) ;
	    //#endif
        } 
    }



    //-- note: this will not be printed if compiled w/o MARLINDEBUG=1 !

    streamlog_out(DEBUG) << "   processing event: " << evt->getEventNumber() 
        << "   in run:  " << evt->getRunNumber() << std::endl ;

    /*
    ofstream IDfile ("IDcheck.txt");
    ofstream R1 ("R0_50.txt", std::ios_base::app);
    ofstream R2 ("R50_1500.txt", std::ios_base::app);
    ofstream R3 ("R1500_2000.txt", std::ios_base::app);
    ofstream R4 ("R2000.txt", std::ios_base::app);
    ofstream R5 ("RMistake.txt", std::ios_base::app); */

    /*    for (int i = 0; i <= vX.size(); i++) {
      float rz = sqrt((vX[i]*vX[i])+(vY[i]*vY[i]));
      if (rz <= 50) {
	R1 << "Cell ID: " << vCellID0[i] << ", " << vCellID1[i] << std::endl;
	R1 << "R:" << rz << "  X:" << vX[i] << "  Y:" << vY[i] << "  Z:" << vZ[i] << "  Layer:" << vLayer[i] << "  Module:" << vModule[i] << "  Stave:" << vStave[i] << std::endl;
      } else if ((rz > 50) && (rz <= 1500)) {
	R2 << "Cell ID: " << vCellID0[i] << ", " << vCellID1[i] << std::endl;
	R2 << "R:" << rz << "  X:" << vX[i] << "  Y:" << vY[i] << "  Z:" << vZ[i] << "  Layer:" << vLayer[i] << "  Module:" << vModule[i] << "  Stave:" << vStave[i] << std::endl;
      } else if ((rz > 1500) && (rz <= 2000)) {
	R3 << "Cell ID: " << vCellID0[i] << ", " << vCellID1[i] << std::endl;
	R3 << "R:" << rz << "  X:" << vX[i] << "  Y:" << vY[i] << "  Z:" << vZ[i] << "  Layer:" << vLayer[i] << "  Module:" << vModule[i] << "  Stave:" << vStave[i] << std::endl;
      } else if (rz > 2000) {
	R4 << "Cell ID: " << vCellID0[i] << ", " << vCellID1[i] << std::endl;
	R4 << "R:" << rz << "  X:" << vX[i] << "  Y:" << vY[i] << "  Z:" << vZ[i] << "  Layer:" << vLayer[i] << "  Module:" << vModule[i] << "  Stave:" << vStave[i] << std::endl;
      } else {
	R5 << "Cell ID: " << vCellID0[i] << ", " << vCellID1[i] << std::endl;
	R5 << "R:" << rz << "  X:" << vX[i] << "  Y:" << vY[i] << "  Z:" << vZ[i] << "  Layer:" << vLayer[i] << "  Module:" << vModule[i] << "  Stave:" << vStave[i] << std::endl;
      }

      if (rz < 1500) {
	if (IDfile.is_open()) {
	  IDfile << "Cell ID: " << vCellID0[i] << ", " << vCellID1[i] << std::endl;
	  IDfile << "R:" << rz << "  X:" << vX[i] << "  Y:" << vY[i] << "  Z:" << vZ[i] << "  Layer:" << vLayer[i] << "  Module:" << vModule[i] << "  Stave:" << vStave[i] << std::endl;
	}
      }
    }
    */

    _nEvt ++ ;
}



void MyHitPositions::check( LCEvent * evt ) { 
    // nothing to check here - could be used to fill checkplots in reconstruction processor
}


void MyHitPositions::end(){ 

    //   std::cout << "MyHitPositions::end()  " << name() 
    // 	    << " processed " << _nEvt << " events in " << _nRun << " runs "
    // 	    << std::endl ;
  //AddBranch( TPosition, "x", vX);
  //AddBranch( TPosition, "y", vY);
  //AddBranch( TPosition, "z", vZ);
  //AddBranch( TPosition, "layer", vLayer);
  //AddBranch( TPosition, "stave", vStave);
  //AddBranch( TPosition, "module", vModule);
  //AddBranch( TPosition, "energy", vEnergy);

  /*  AddBranch(tHits, "X", vX);
  AddBranch(tHits, "Y", vY);
  AddBranch(tHits, "Z", vY);
  AddBranch(tHits, "Layer", vLayer);
  AddBranch(tHits, "Stave", vStave);
  AddBranch(tHits, "Module", vModule);
  AddBranch(tHits, "Energy", vEnergy);
  */
  
  const char* rootchar = rootfile.c_str();
  TFile *hfile = new TFile(rootchar,"recreate");
  hX->Write("X");
  hY->Write("Y");
  hZ->Write("Z");
  hLayer->Write("Layer");
  hStave->Write("Stave");
  hModule->Write("Module");
  hEnergy->Write("Energy");

  hNHits->Write("NHits");
  hRecoEnergy->Write("RecoEnergy");
  hMCEnergy->Write("MCEnergy");

  hXY->Write("X_vs_Y");
  hXLayer->Write("X_vs_Layer");
  hYLayer->Write("Y_vs_Layer");

  

  //hXYLayer->Write("X_vs_Y_vs_Layer");

  hfile->Close();

  

}

//USER DEFINED FUNCTIONS


void MyHitPositions::GetStuff(LCCollection* calhit, std::vector<float>& _vXpos_raw, std::vector<float>& _vYpos_raw, std::vector<float>& _vZpos_raw, std::vector<int>& _vLayer, std::vector<int>& _vStave, std::vector<int>& _vModule, std::vector<float>& _vEnergy, std::vector<int>& _vCellID0, std::vector<int>& _vCellID1)
{

  if( calhit != NULL )
    {
      int nCH = calhit->getNumberOfElements()  ;

      for (int i=0; i<nCH ; i++)
        {
          SimCalorimeterHit* A = dynamic_cast<SimCalorimeterHit*>( calhit->getElementAt( i ) ) ;
          _vCellID0.push_back(A->getCellID0());
	  _vCellID1.push_back(A->getCellID1());
	  _vXpos_raw.push_back(A->getPosition()[0]);
          _vYpos_raw.push_back(A->getPosition()[1]);
          _vZpos_raw.push_back(A->getPosition()[2]);
	  
	  

          CellIDDecoder<SimCalorimeterHit> idDecoder( calhit );
	  //std::cout << "iddecode (lsm): " << idDecoder(A)["layer"] << ": " << idDecoder(A)["stave"] << ": " << idDecoder(A)["module"] << std::endl;
	  
          int layer = idDecoder(A)["layer"];
          int stave = idDecoder(A)["stave"];
          int module = idDecoder(A)["module"];

	  if (layer < 0) {
	    std::cout << "HELP: LAYER IS " << layer << std::endl;
	  }

          _vLayer.push_back(layer);
          _vStave.push_back(stave);
          _vModule.push_back(module);
	  
	  _vEnergy.push_back(A->getEnergy());
        }
    }

}

void MyHitPositions::FillHistogram(std::vector<float> data, TH1F* histogram)
{
  for (int i = 0; i < data.size(); i++) {
    histogram->Fill(data[i]);
  } 
}

void MyHitPositions::FillHistogramInt(std::vector<int> data, TH1F* histogram)
{
  for (int i = 0; i < data.size(); i++) {
    histogram->Fill(data[i]);
  } 
}

void MyHitPositions::Fill2DHistogram(std::vector<float> data_x, std::vector<float> data_y, TH2F* histogram)
{
  if (data_x.size() != data_y.size()) {
    streamlog_out(WARNING) << "Filling 2D Histogram:: Size of data_x is not equal to the size of data_y;  " << data_x.size() << " != " << data_y.size() << std::endl;
  } else {
    for (int i = 0; i < data_x.size(); i++) {
      histogram->Fill(data_x[i], data_y[i]);
    } 
  }
}

/*void MyHitPositions::Fill3DHistogram(std::vector<float> data_x, std::vector<float> data_y, std::vector<float> data_z, TH3F* histogram)
{
  if (data_x.size() != data_y.size() || data_x.size() != data_z.size()) {
    streamlog_out(WARNING) << "Filling 2D Histogram:: Size of data_x is not equal to either the size of data_y or data z;  " << data_x.size() << " != " << data_y.size() << " or " << data_z.size() << std::endl;
  } else {
    for (int i = 0; i <= data_x.size(); i++) {
      histogram->Fill(data_x[i], data_y[i], data_z[i]);
    } 
  }
  std::cout << "heythere" << std::endl;
}
*/

void MyHitPositions::AddBranch( TTree* input_tree, std::string title, std::vector<float> data )
{
  if( (input_tree->GetEntries() != (int)data.size()) && (input_tree->GetEntries() != 0) )
    {
      std::cout << "ERROR: CANNOT ADD BRANCH " << title << " DATA SIZE DID NOT MATCH TREE."
                << "Data size: " << data.size() <<  std::endl;
      return;
    }

  float thisValue=0.;
  TString name=title.c_str();
  name.Append("/F");
  TBranch* output_branch_obj = input_tree->Branch( title.c_str(), &thisValue, name );

  input_tree->SetEntries( (int)data.size() );

  for( unsigned int i=0; i< data.size(); ++i )
    {
      thisValue = data[i];
      output_branch_obj->Fill();
    }
}



void MyHitPositions::ClearVector( std::vector<float>& _vXpos_raw, std::vector<float>& _vYpos_raw, std::vector<float>& _vZpos_raw, std::vector<int>& _vLayer, std::vector<int>& _vStave, std::vector<int>& _vModule, std::vector<float>& _vEnergy,  std::vector<int>& _vCell1, std::vector<int>& _vCell2)  // Need to clear Cell ID vectors.
{

  _vXpos_raw.clear();
  _vXpos_raw.resize(0);

  _vYpos_raw.clear();
  _vYpos_raw.resize(0);
  
  _vZpos_raw.clear();
  _vZpos_raw.resize(0);

  _vLayer.clear();
  _vLayer.resize(0);

  _vStave.clear();
  _vStave.resize(0);

  _vModule.clear();
  _vModule.resize(0);

  _vEnergy.clear();
  _vEnergy.resize(0);

  _vCell1.clear();
  _vCell1.resize(0);  

  _vCell2.clear();
  _vCell2.resize(0);  

}
